 *December 2020: This is a draft of a technical plan, a set of changes
  intended for the whole GnuCOBOL codebase. When consensus is reached,
  this introductory notice can be removed.*
  
Objectives 
==========

The purpose of this plan is to improve the code and associated
documentation. The code would be revised to adhere more closely to
current standards and practices, and the documentation will be
re-organized to make it both easier to maintain and possible to
improve.

Code
----

The first objective of the changes outlined in this plan is to make
the code easier to understand by

* adhering to Posix and C standards
* minimizing use of proprietary wrapper/replacement functions
* avoiding use of the preprocessor

to the extent possible. 

By standardizing the code, we make it more approachable by new
contributors, reduce errors of our own making, and possibly allow the
compiler to generate more efficient code. 

By relying on standard functions and idioms, we reduce code complexity
and possibly the overall lines of code to maintain.

Documentation
-------------

The other objective is to improve the documentation by changing how it
is maintained and produced.

Topics 
======

* "Supported" Environments
* C language
* C standard library
* C preprocessor
* Documentation

"Supported" Environments
========================

Enumerate the compilers expected to compile the project, and the
compilers used by cobc.  Of those, enumerate defects with regard to
support for standards: missing features of the C language and the C
standard library. Things we "can't do" because we wish a particular
compiler to continue to be available to the user need to be
documented.  All else is fair game.

After enumerating all target environments, create a *union of all
flaws*. Check that list against the quirks currently dealt with in
**configure.ac**, and eliminate anything that doesn't apply. For
example, if all environments support **snprintf**(3), it's not
necessary to check for it at configure time, or to carry the
complexity of conditional compilation.

C Language
==========

C11
---

Adopt C11 idioms and language features. 

The C11 standard made some parts of C99, such as VLAs,
optional. Microsoft claims C11 support in recent releases of Visual
Studio. Many useful parts of C11 have been widely available for over a
decade, including:

* stdint.h
* stdbool.h
* just-in-time variable definition
* designated initializers
* // comments
* inline functions
* static_assert

Other useful features that are sadly *unlikely* to find universal support:

* variable-length arrays
* _Generic (overloaded functions)

Casts
-----

A cast is a signal to someone reading the code that something unusual
is going on. An unnecessary cast sends the wrong signal. 

Casts to/from **void\*** are unnecessary.  Casts of a parameter to
the function's declared type are *usually* unnecessary, as are casts
to a function's return type. If implicit promotion/conversion produces
the same effect without the cast, the cast is unnecessary and should
be removed.

At last count, there were some 1500 casts in the code base, many
superfluous.

James K. Lowden wrote a tool, 
[cscan](https://gitlab.cobolworx.com/COBOLworx/cscan) 
to identify casts. 

unlikely
--------

As of this writing, there are 309 uses of **unlikely**, which is a
macro for `__builtin_expect`. *Perhaps* one is justified. 

C11 types
---------

The codebase makes extensive use of **int** in two ways that are
old-fashioned by today's standards:

* as a stand-in for a Boolean
* as a length, where `size_t` appropriate

We should identify such uses and replace them. For any that we decide
to keep as-is for some reason, a comment should reflect the rationale.

`stdint.h` defines fixed-size integer types. We should replace
home-grown names and preprocessor cruft with standard types.


C standard library
==================

The project has two distinct use cases: 

1. The C source code written by humans
2. The C source code generated by **cobc**.

Code written by humans (and for humans) should use the standard
library wherever possible. For platforms that lack a particular
function, we can provide a substitute. This policy makes the code
easier to understand. 

Generated code has the opposite constraint: it must *not* use the
standard library. In fact, when generated code is compiled, the
compiler should be instructed not to link to any library but
**libcob**.

Wrapper module
--------------

This dichotomy places a peculiar burden on **libcob**: to provide C
standard library functionality under different symbols. Such wrapper
functions should be in their own module, and should introduce *no* new
logic.  They simply rename the symbol to allow **libcob** to forward
the function call to the underlying standard function.

One may be tempted to add "helper" code to the wrapper function,
perhaps error handling. Experience shows this strategy is less
effective than it might seem (which is why **throw** was added to
C++). Errors are better handled as *high* in the code as possible,
close to the semantic use, where a meaningful message can be crafted.

The wrapper functions supply C standard functions to generated code
*only*. Under no circumstances should the compiler or library itself
call them.  Because they are completely standard, just renamed, using
them would only serve to confuse the reader.

Standard functions
------------------

Quite a few standard functions are re-implemented, ignored, or wrapped
with additional logic. If a standard function exists, it should be
used.  If it does not exist on a specific platform, we should provide
it. Very often, existing implementations are freely available. 

For example, **free**(3) is wrapped by a function to exit with an
error if the pointer argument is `NULL`. There are 238 uses of
**cob_free**, many of which are guarded by *if pointer is not NULL*,
and nearly all of which can be reduced to **free**(3).

Only recently, revision 4074 introduced a signal-handler table with
signal descriptions. A better choice would have been to use
**strsignal**(3) and provide an implementation of that function for
platforms that don't support it.

Symbol names
------------

The code contains many names with unnecessary prefixes.  If there's
any rhyme or reason to these prefixes, they're not mentioned in
HACKING.

For example: 

    cobc.c        273 static size_t  cobc_cflags_len;

Static variables and functions do not need the `cobc` prefix. It would
be best if *no* local symbols had such a prefix. 

There almost 10,000 references to symbols starting with `cb_`. It's
unclear what purpose is served by say, using `cb_listing_header`
instead of, perhaps, `header`.

There are 1597 occurrences of symbols prefixed with `cobc_`. 

The names could be shortened by removing the prefixes. Public symbols
that provide documented runtime support, on the other hand -- symbols
used by **cobc** or generated code -- should be distinguished by a
unique prefix.

As a general rule, symbol names get longer with increased scope
because their use lacks surrounding context. Removing prefixes from
static symbols is just a specific application of that rule.

assert.h
--------

**assert*(3) appears exactly twice in the codebase, in debug.c, while
printing the AST. It should be used *much* more extensively. 

Do not try to convert a *logic error* into a *runtime error*.  If the
situation is "impossible", if it could be remedied only by changing
the program, **assert** is appropriate. There's nothing the user can
do, and message gives the programmer valuable information. 

Signals
-------

It is unnecessary to closely distinguish between platforms that
support **signal**(2) and **sigaction**(2).  *The Linux Programming
Interface* by Michael Kerrisk includes an implementation of signal
using sigaction.  It is 20 lines long. We should simply use signal
everywhere, and collect anything specific to sigaction in one module.

Signal handling is currently done using functions that are not
signal-safe. We have discussed ways to expose the signal's effect to
the Cobol program and simplify how the library/program
responds. Signal handling in **cobc** can be radically simplified by
reducing it to removing partially written files.

Preprocessor
------------

There is a consensus among C programmers that the preprocessor is best
avoided to the extent possible. This the project does not do.  There
are 2532 uses of `#if` in the codebase, about 2% of the overall code.

Two common uses can be replaced by the
C compiler with equal or better efficiency and functionality.

1. `#define` *constant* is better done as `enum`. 
2. function-style macros may be replaced with `inline` functions. 

One anti-pattern that sees some use in GnuCOBOL is a preprocessor
symbol that expands to include a `return` statement. Such code is
confusing to read and can always be re-written in a conventional way
with no loss of functionality.

Finally, conditional compilation can frequently be avoided by using
standard values and static functions.  For example:

    #if defined(WITH_INDEX_EXTFH) || defined(WITH_CISAM) || defined(WITH_DISAM) \
    	|| defined(WITH_VBISAM) || defined(WITH_DB) || defined(WITH_LMDB) \
    	|| defined(WITH_ODBC) || defined(WITH_OCI)
    #if defined	(WITH_INDEX_EXTFH)
    	cobc_var_print (_("indexed file handler"),		"EXTFH (obsolete)", 0);
    #endif

could be replaced by 

	if( feature_word & feature_mask.db ) {
    	cobc_var_print (_("indexed file handler"),		"EXTFH (obsolete)", 0);
	}

By using and supplying standard functions, nearly all
platform-specific conditional compilation can be removed. For example:

    #ifdef	HAVE_LOCALE_H
    #include <locale.h>
    #endif
    
and

    #if	defined (_WIN32) || defined (__CYGWIN__)
    static char *
    cobc_stradd_dup (const char *str1, const char *str2)
    {
    ...
    }
    #endif

Whatever Linux does without `cobc_stradd_dup` could be supplied under
Windows by the same name.  It looks like it might be a candidate for
**asprint**(3).

Documentation
=============

The manual produced with **cobc** is incomplete. It has technical and
human problems that are best redressed by different system to write
and manage it.

To take just one example, the **cobc**(1) man page includes no
reference to the rest of the project, or to the Programmer's Guide,
and makes no mention of environment variables that control compilation
and the behavior of produced binaries.

The whole manual is likewise incomplete.  For example, section 3.1,
*Customizing compiler* [sic] currently has: 

  'COB_LDFLAGS'
       Flags passed to the C compiler ("")
	   
which is incorrect.  It also include *no mention* of how the command
line is constructed or where the user-provided values occur relative
to the built-in values, or how to capture/alter the built-in defaults. 

That's just one page. 

Part of the problem is sheer lack of manpower. Writing a manual takes
time and painstaking attention. 

But part is technical: the documentation is generated (in part) from
the output of `cobc --help`.  While that keeps the manual and on-line
help synchronized, it also prevents the person providing the text -- the
person writing the "manual" -- from seeing it in context. That person
is precluded from using any typographical hints to make the text
clearer, or following any documentation model, such as the one defined
for Unix man pages.

Redesign
--------

Replace the *help-to-doc* process with its opposite:
*doc-to-help*. Instead of generating the documentation from compiled
binaries, maintain the manual as a free-standing document, and
extract help-text from it, to generate source-code modules. 

The best markup language for documentation is, objectively, **groff**
*mdoc*. It is a relatively simple matter, with **nroff**(1), to
extract the manual as text, and use **awk**(1) or similar to transform
it into C source code arrays. 

This redesign will relieve us of the technical problems associated
with *adding* markup to the plain text produced from the help, and
allow us to write a much better manual. 

Results
=======

When the code is revamped as described above, the *user* will see
almost no effect. There are no syntax changes, no new functions, no
new features of any kind. 

Why do it, then? 

For the same reason you might wash a stack of dishes in the sink: to
make the place presentable, and to make the next steps easier and more
pleasant.

Standard code is easier to read and easier to write.  Is is more
reliable for those reasons, and because it avoids bespoke replacements
for standard functions (when available). Code that is easy to
understand also invites collaborators. The number of current
collaborators suggests the codebase hasn't tempted too many to dive
in. 

Standard code is also *educational*. It frees developers from
the kind of limitations they often face at work.  It teaches them good
C practices, and the difference between what a given compiler accepts
(and does) and what the C standard says is correct.

Finally, standard code improves quality.  (Documentation improves
quality, too.) Some of the changes outlined above will doubtless
reveal errors, too, however subtle, in pointer conversion and integer
promotion. The compiler will produce better diagnostics, and likely
better object code.

<!-- LocalWords: preprocessor -->
